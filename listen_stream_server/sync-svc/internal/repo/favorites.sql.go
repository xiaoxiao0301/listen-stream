// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: favorites.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFavorites = `-- name: CountFavorites :one
SELECT COUNT(*) FROM favorites
WHERE user_id = $1
  AND deleted_at IS NULL
  AND ($2::text = '' OR type = $2)
`

type CountFavoritesParams struct {
	UserID string `json:"user_id"`
	Type   string `json:"type"`
}

func (q *Queries) CountFavorites(ctx context.Context, arg CountFavoritesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFavorites, arg.UserID, arg.Type)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFavorite = `-- name: CreateFavorite :one

INSERT INTO favorites (user_id, type, target_id)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, type, target_id) DO UPDATE
  SET deleted_at = NULL  -- 若之前软删除过，重新激活
RETURNING id, user_id, type, target_id, deleted_at, created_at
`

type CreateFavoriteParams struct {
	UserID   string `json:"user_id"`
	Type     string `json:"type"`
	TargetID string `json:"target_id"`
}

// ============================================================
// favorites 查询（软删除模型）
// 使用服务：sync-svc
// ============================================================
// ON CONFLICT DO NOTHING 保证幂等（重复添加不报错）
func (q *Queries) CreateFavorite(ctx context.Context, arg CreateFavoriteParams) (Favorite, error) {
	row := q.db.QueryRow(ctx, createFavorite, arg.UserID, arg.Type, arg.TargetID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.TargetID,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getFavoriteByID = `-- name: GetFavoriteByID :one
SELECT id, user_id, type, target_id, deleted_at, created_at FROM favorites WHERE id = $1 AND user_id = $2
`

type GetFavoriteByIDParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetFavoriteByID(ctx context.Context, arg GetFavoriteByIDParams) (Favorite, error) {
	row := q.db.QueryRow(ctx, getFavoriteByID, arg.ID, arg.UserID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.TargetID,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getFavoriteByTarget = `-- name: GetFavoriteByTarget :one
SELECT id, user_id, type, target_id, deleted_at, created_at FROM favorites
WHERE user_id = $1 AND type = $2 AND target_id = $3 AND deleted_at IS NULL
`

type GetFavoriteByTargetParams struct {
	UserID   string `json:"user_id"`
	Type     string `json:"type"`
	TargetID string `json:"target_id"`
}

func (q *Queries) GetFavoriteByTarget(ctx context.Context, arg GetFavoriteByTargetParams) (Favorite, error) {
	row := q.db.QueryRow(ctx, getFavoriteByTarget, arg.UserID, arg.Type, arg.TargetID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.TargetID,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listDeletedFavoritesSince = `-- name: ListDeletedFavoritesSince :many
SELECT id FROM favorites
WHERE user_id = $1
  AND deleted_at IS NOT NULL
  AND deleted_at > $2
`

type ListDeletedFavoritesSinceParams struct {
	UserID    string             `json:"user_id"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

// /user/sync?since= 拉取软删除的收藏 ID
func (q *Queries) ListDeletedFavoritesSince(ctx context.Context, arg ListDeletedFavoritesSinceParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listDeletedFavoritesSince, arg.UserID, arg.DeletedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavorites = `-- name: ListFavorites :many
SELECT id, user_id, type, target_id, deleted_at, created_at FROM favorites
WHERE user_id = $1
  AND deleted_at IS NULL
  AND ($4::text = '' OR type = $4)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListFavoritesParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Type   string `json:"type"`
}

// 分页；type 为空字符串时查全部类型
func (q *Queries) ListFavorites(ctx context.Context, arg ListFavoritesParams) ([]Favorite, error) {
	rows, err := q.db.Query(ctx, listFavorites,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.Type,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Favorite
	for rows.Next() {
		var i Favorite
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.TargetID,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoritesSince = `-- name: ListFavoritesSince :many
SELECT id, user_id, type, target_id, deleted_at, created_at FROM favorites
WHERE user_id = $1
  AND deleted_at IS NULL
  AND created_at > $2
`

type ListFavoritesSinceParams struct {
	UserID    string             `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// /user/sync?since= 拉取新增收藏
func (q *Queries) ListFavoritesSince(ctx context.Context, arg ListFavoritesSinceParams) ([]Favorite, error) {
	rows, err := q.db.Query(ctx, listFavoritesSince, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Favorite
	for rows.Next() {
		var i Favorite
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.TargetID,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteFavorite = `-- name: SoftDeleteFavorite :one
UPDATE favorites
SET deleted_at = NOW()
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
RETURNING id, user_id, type, target_id, deleted_at, created_at
`

type SoftDeleteFavoriteParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) SoftDeleteFavorite(ctx context.Context, arg SoftDeleteFavoriteParams) (Favorite, error) {
	row := q.db.QueryRow(ctx, softDeleteFavorite, arg.ID, arg.UserID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.TargetID,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

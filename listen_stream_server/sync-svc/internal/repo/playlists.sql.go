// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlists.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSongToPlaylist = `-- name: AddSongToPlaylist :one
INSERT INTO playlist_songs (playlist_id, song_mid, sort_order)
VALUES ($1, $2, $3)
RETURNING id, playlist_id, song_mid, sort_order, added_at
`

type AddSongToPlaylistParams struct {
	PlaylistID string `json:"playlist_id"`
	SongMid    string `json:"song_mid"`
	SortOrder  int32  `json:"sort_order"`
}

func (q *Queries) AddSongToPlaylist(ctx context.Context, arg AddSongToPlaylistParams) (PlaylistSong, error) {
	row := q.db.QueryRow(ctx, addSongToPlaylist, arg.PlaylistID, arg.SongMid, arg.SortOrder)
	var i PlaylistSong
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.SongMid,
		&i.SortOrder,
		&i.AddedAt,
	)
	return i, err
}

const compactSortOrder = `-- name: CompactSortOrder :exec
UPDATE playlist_songs
SET sort_order = sort_order - 1
WHERE playlist_id = $1 AND sort_order > $2
`

type CompactSortOrderParams struct {
	PlaylistID string `json:"playlist_id"`
	SortOrder  int32  `json:"sort_order"`
}

// 删除歌曲后，将 sort_order 大于被删位置的记录减 1
func (q *Queries) CompactSortOrder(ctx context.Context, arg CompactSortOrderParams) error {
	_, err := q.db.Exec(ctx, compactSortOrder, arg.PlaylistID, arg.SortOrder)
	return err
}

const createPlaylist = `-- name: CreatePlaylist :one


INSERT INTO user_playlists (user_id, name)
VALUES ($1, $2)
RETURNING id, user_id, name, deleted_at, updated_at, created_at
`

type CreatePlaylistParams struct {
	UserID string `json:"user_id"`
	Name   string `json:"name"`
}

// ============================================================
// playlists + playlist_songs 查询
// 使用服务：sync-svc
// ============================================================
// ── user_playlists ──────────────────────────────────────────
func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) (UserPlaylist, error) {
	row := q.db.QueryRow(ctx, createPlaylist, arg.UserID, arg.Name)
	var i UserPlaylist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getNextSortOrder = `-- name: GetNextSortOrder :one

SELECT COALESCE(MAX(sort_order) + 1, 0)
FROM playlist_songs
WHERE playlist_id = $1
`

// ── playlist_songs ──────────────────────────────────────────
// 追加歌曲时获取下一个 sort_order
func (q *Queries) GetNextSortOrder(ctx context.Context, playlistID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getNextSortOrder, playlistID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getPlaylistByID = `-- name: GetPlaylistByID :one
SELECT id, user_id, name, deleted_at, updated_at, created_at FROM user_playlists
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type GetPlaylistByIDParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetPlaylistByID(ctx context.Context, arg GetPlaylistByIDParams) (UserPlaylist, error) {
	row := q.db.QueryRow(ctx, getPlaylistByID, arg.ID, arg.UserID)
	var i UserPlaylist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPlaylistSong = `-- name: GetPlaylistSong :one
SELECT id, playlist_id, song_mid, sort_order, added_at FROM playlist_songs
WHERE playlist_id = $1 AND song_mid = $2
`

type GetPlaylistSongParams struct {
	PlaylistID string `json:"playlist_id"`
	SongMid    string `json:"song_mid"`
}

func (q *Queries) GetPlaylistSong(ctx context.Context, arg GetPlaylistSongParams) (PlaylistSong, error) {
	row := q.db.QueryRow(ctx, getPlaylistSong, arg.PlaylistID, arg.SongMid)
	var i PlaylistSong
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.SongMid,
		&i.SortOrder,
		&i.AddedAt,
	)
	return i, err
}

const listDeletedPlaylistsSince = `-- name: ListDeletedPlaylistsSince :many
SELECT id FROM user_playlists
WHERE user_id = $1 AND deleted_at IS NOT NULL AND deleted_at > $2
`

type ListDeletedPlaylistsSinceParams struct {
	UserID    string             `json:"user_id"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) ListDeletedPlaylistsSince(ctx context.Context, arg ListDeletedPlaylistsSinceParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listDeletedPlaylistsSince, arg.UserID, arg.DeletedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylistSongs = `-- name: ListPlaylistSongs :many
SELECT id, playlist_id, song_mid, sort_order, added_at FROM playlist_songs
WHERE playlist_id = $1
ORDER BY sort_order ASC
`

func (q *Queries) ListPlaylistSongs(ctx context.Context, playlistID string) ([]PlaylistSong, error) {
	rows, err := q.db.Query(ctx, listPlaylistSongs, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlaylistSong
	for rows.Next() {
		var i PlaylistSong
		if err := rows.Scan(
			&i.ID,
			&i.PlaylistID,
			&i.SongMid,
			&i.SortOrder,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylistsSince = `-- name: ListPlaylistsSince :many
SELECT id, user_id, name, deleted_at, updated_at, created_at FROM user_playlists
WHERE user_id = $1 AND updated_at > $2 AND deleted_at IS NULL
`

type ListPlaylistsSinceParams struct {
	UserID    string             `json:"user_id"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// /user/sync?since= 拉取变更歌单
func (q *Queries) ListPlaylistsSince(ctx context.Context, arg ListPlaylistsSinceParams) ([]UserPlaylist, error) {
	rows, err := q.db.Query(ctx, listPlaylistsSince, arg.UserID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserPlaylist
	for rows.Next() {
		var i UserPlaylist
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserPlaylists = `-- name: ListUserPlaylists :many
SELECT
  p.id, p.user_id, p.name, p.deleted_at, p.updated_at, p.created_at,
  COUNT(ps.id) AS song_count
FROM user_playlists p
LEFT JOIN playlist_songs ps ON ps.playlist_id = p.id
WHERE p.user_id = $1 AND p.deleted_at IS NULL
GROUP BY p.id
ORDER BY p.created_at ASC
`

type ListUserPlaylistsRow struct {
	ID        string             `json:"id"`
	UserID    string             `json:"user_id"`
	Name      string             `json:"name"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	SongCount int64              `json:"song_count"`
}

func (q *Queries) ListUserPlaylists(ctx context.Context, userID string) ([]ListUserPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, listUserPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserPlaylistsRow
	for rows.Next() {
		var i ListUserPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.SongCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSongFromPlaylist = `-- name: RemoveSongFromPlaylist :one
DELETE FROM playlist_songs
WHERE playlist_id = $1 AND song_mid = $2
RETURNING sort_order
`

type RemoveSongFromPlaylistParams struct {
	PlaylistID string `json:"playlist_id"`
	SongMid    string `json:"song_mid"`
}

func (q *Queries) RemoveSongFromPlaylist(ctx context.Context, arg RemoveSongFromPlaylistParams) (int32, error) {
	row := q.db.QueryRow(ctx, removeSongFromPlaylist, arg.PlaylistID, arg.SongMid)
	var sort_order int32
	err := row.Scan(&sort_order)
	return sort_order, err
}

const softDeletePlaylist = `-- name: SoftDeletePlaylist :exec
UPDATE user_playlists
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type SoftDeletePlaylistParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) SoftDeletePlaylist(ctx context.Context, arg SoftDeletePlaylistParams) error {
	_, err := q.db.Exec(ctx, softDeletePlaylist, arg.ID, arg.UserID)
	return err
}

const updatePlaylistName = `-- name: UpdatePlaylistName :one
UPDATE user_playlists
SET name = $2, updated_at = NOW()
WHERE id = $1 AND user_id = $3 AND deleted_at IS NULL
RETURNING id, user_id, name, deleted_at, updated_at, created_at
`

type UpdatePlaylistNameParams struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	UserID string `json:"user_id"`
}

func (q *Queries) UpdatePlaylistName(ctx context.Context, arg UpdatePlaylistNameParams) (UserPlaylist, error) {
	row := q.db.QueryRow(ctx, updatePlaylistName, arg.ID, arg.Name, arg.UserID)
	var i UserPlaylist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

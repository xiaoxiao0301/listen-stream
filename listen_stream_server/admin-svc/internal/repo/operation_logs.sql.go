// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: operation_logs.sql

package repo

import (
	"context"
)

const countOperationLogs = `-- name: CountOperationLogs :one
SELECT COUNT(*) FROM operation_logs
WHERE ($1::text = '' OR action = $1)
`

func (q *Queries) CountOperationLogs(ctx context.Context, action string) (int64, error) {
	row := q.db.QueryRow(ctx, countOperationLogs, action)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOperationLog = `-- name: CreateOperationLog :one

INSERT INTO operation_logs (admin_id, action, target_id, before_val, after_val, ip)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, admin_id, action, target_id, before_val, after_val, ip, created_at
`

type CreateOperationLogParams struct {
	AdminID   string  `json:"admin_id"`
	Action    string  `json:"action"`
	TargetID  *string `json:"target_id"`
	BeforeVal *string `json:"before_val"`
	AfterVal  *string `json:"after_val"`
	Ip        string  `json:"ip"`
}

// ============================================================
// operation_logs 查询（追加写，不可修改/删除）
// 使用服务：admin-svc（写）、admin-svc（读查询）
// ============================================================
func (q *Queries) CreateOperationLog(ctx context.Context, arg CreateOperationLogParams) (OperationLog, error) {
	row := q.db.QueryRow(ctx, createOperationLog,
		arg.AdminID,
		arg.Action,
		arg.TargetID,
		arg.BeforeVal,
		arg.AfterVal,
		arg.Ip,
	)
	var i OperationLog
	err := row.Scan(
		&i.ID,
		&i.AdminID,
		&i.Action,
		&i.TargetID,
		&i.BeforeVal,
		&i.AfterVal,
		&i.Ip,
		&i.CreatedAt,
	)
	return i, err
}

const listOperationLogs = `-- name: ListOperationLogs :many
SELECT id, admin_id, action, target_id, before_val, after_val, ip, created_at FROM operation_logs
WHERE ($3::text = '' OR action = $3)
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOperationLogsParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Action string `json:"action"`
}

func (q *Queries) ListOperationLogs(ctx context.Context, arg ListOperationLogsParams) ([]OperationLog, error) {
	rows, err := q.db.Query(ctx, listOperationLogs, arg.Limit, arg.Offset, arg.Action)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OperationLog
	for rows.Next() {
		var i OperationLog
		if err := rows.Scan(
			&i.ID,
			&i.AdminID,
			&i.Action,
			&i.TargetID,
			&i.BeforeVal,
			&i.AfterVal,
			&i.Ip,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
